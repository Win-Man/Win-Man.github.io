---
title: 事务状态在数据库中间件中的应用
date: 2018-03-12 11:08:13
tags:
- MySQL
categories:
- MySQL
---
## 1. 简介
在数据库中间件读写分离应用场景中，如何保证底层数据库出现故障节点的时，中间件可以快速断开或迁移数据库连接，让用户无感知。在MySQL数据库中，提供了一个session_track_transaction_info参数，使上面的问题，有了解决方案。
因为官方文档上没有对该参数的说明部分，所以我通过专门通过看代码以及做实验的方式，整理一下关于这个参数的内容。

## 2. session_track_transaction_info参数
### 2.1 参数介绍
MySQL5.7中，可以通过设置session_track_transaction_info变量来跟踪事务的状态。
MySQL官方文档中对该参数没有文档说明。
* 该参数存在global以及session两个级别，可以动态修改。
* 该参数可以设置的值为0（默认OFF），1,2
```
/**
  Transaction tracking level
*/
enum enum_session_track_transaction_info {
  TX_TRACK_NONE      = 0,  ///< do not send tracker items on transaction info
  TX_TRACK_STATE     = 1,  ///< track transaction status
  TX_TRACK_CHISTICS  = 2   ///< track status and characteristics
};
```
看代码中，该参数允许设置的值为0，1，2
* 设置为0的时候，`show variables like '%session_track_transaction_info%'`显示为`OFF`，表示不开启事务状态跟踪
* 设置为1的时候，`show variables like '%session_track_transaction_info%'`显示为`STATE`，表示跟踪事务状态
* 设置为2的时候，`show variables like '%session_track_transaction_info%'`显示为`CHARACTERISTICS`，表示跟踪事务状态和语句
### 2.2 测试记录
开启session_track_transaction_info参数的时候，在数据库中无法直接查询到事务状态记录。根据[WL#4797](https://dev.mysql.com/worklog/task/?id=4797)，MySQL是将事务状态跟踪的信息记录到了每一个Query请求返回的OK packet中。所以通过抓包的方式查看事务状态信息。具体的抓包文件见附件。
MySQL数据包解析可以参照文档《MySQL主备复制网络协议解析》

#### 2.2.1 MySQL如何封装OK packet
**OK Packet的数据包格式定义**
| 类型 | 名字 | 描述 |
| ----- | ----- | ------ |
| int<1> | 头部 | 用0x00或者0xFE表示该数据包是一个OK Packet |
| int<lenenc> | 影响的行数 | 影响的行数 |
| int<lenenc> | 上次插入的id | 上次插入的id |
| int<2> | 状态标识 | 如果定义了CLIENT_PROTOCOL_41,会有这一部分 |
| int<2> | 警告数量 | 警告的数量，如果定义了CLIENT_PROTOCOL_41,会有这一部分 |
| int<2> | 状态标识 | 如果定义了CLIENT_TRANSACTIONS,会有这一部分 |
| string<lenenc> | 信息 | 人类可读的状态信息，如果定义了CLIENT_SESSION_TRACK，会有这一部分 |
| string<lenenc> | 会话状态 | 会话状态信息，如果定义了SERVER_SESSION_STATE_CHANGED,会有这一部分 |
| string<EOF> | 信息 | 人类可读的信息 |
其中`int<lenenc>`和`string<lenenc>`中的lenenc表示的是LengthEcode。

MySQL-5.7.19代码中封装OK packet的代码部分在protocol_classic.cc文件中的`net_send_ok()`函数中。


#### 2.2.3 session_track_transaction_info 显示信息
session_track_transaction_info使用8个字符位来表示事务的信息，并且这8个字符信息是保存在COM_QUERY请求语句的返回数据包中的（客户端执行一条语句，都会被封装成MySQL协议中的COM_QUERY请求发送给server端，server端解析执行之后将结果封装在数据包中返回）。
| 位置 | 表示信息 | 具体代表含义 |
| ----- | ---------- | ---------------- |
| Place 1 | Transaction | T 显式的开启一个事务 <br> I 隐式的开启一个事务（@autocommit=0）<br> _ 没有活跃的事务 |
| Place 2 | unsafe read | r 当前事务中读取了非事务性存储引擎的表 <br> _ 当前事务中没有读取非事务性存储引擎的表 |
| Place 3 | transaction read | R 当前事务中读取了事务性存储引擎的表 <br> _ 当前事务中没有读取事务性存储引擎的表 |
| Place 4 | unsafe wirte | w 当前事务中写入了非事务性存储引擎的表 <br> _  当前事务中没有写入非事务性存储引擎的表 |
| Place 5 | transaction write | W 当前事务中写入了事务性存储引擎的表 <br> _ 当前事务中没有写入事务性存储引擎的表 |
| Place 6 | unsafe statement | s 当前事务中使用了不安全的语句，类似于UUID() <br> _ 没有使用类似的不安全的语句 |
| Place 7 | result-set | S 发送给了客户端一个结果集 <br> _ 没有结果集 | 
| Place 8 | LOCKed TABLES | L 表被显式的通过LOCK TABLES 语句上锁了 <br> _ 当前事务中没有锁表 | 
#### 2.2.2 session_track_transaction_info = 0
```
## session_track_transaction_info = 0
客户端执行begin；封装的数据包
06 00 00 # playload_length
00 # sequence_id
03 # command_type COM_QUERY
62 65 67 69 6e # begin

server端返回的数据包：response 
07 00 00 # playload_length 
01 # sequence_id
00 # 头部 0x00表示是一个OK包
00 # 影响的行数 0
00 # 上次插入的id
03000000

客户端执行insert into t1 values(55)封装的数据包
1a 00 00 # playload_length 
00 # sequence_id
03 # command_type COM_QUERY
696e7365727420696e746f2074312076616c75657328353529 # insert into t1 values(55)

server端返回的数据包：response
07 00 00 # playload_length
01 # sequence_id
00010003000000

客户端执行commit；封装的数据包
07 00 00 # playload_length
00 # sequence_id
03 # command_type COM_QUERY
636f6d6d6974 # commit

server端返回的数据库包：response
07 00 00 # playload_length
01 # sequence_id
00000002000000
```
session_track_transaction_info=0表示不记录事务信息，所有在server端返回的数据包中没有事务状态跟踪信息。
#### 2.2.4 session_track_transaction_info = 1
```
## session_track_transaction_info = 1
客户端执行begin；封装的数据包
06 00 00 # playload_length
00 # sequence_id
03 # command_type COM_QUERY
626567696e # begin

server端返回的数据包：response
14 00 00 # playload_length
01 # sequence_id
00 # 头部 0x00表示是一个OK包
00 # 影响的行数 0
00 # 上次插入的id
03400000000b050908
54 5f 5f 5f 5f 5f 5f 5f 
# 事务状态信息 T_______
# Place 1: 54 //显式的开启一个事务
# Place 2: 5f //当前事务中没有读取非事务性存储引擎的表
# Place 3: 5f //当前事务中没有读取事务性存储引擎的表
# Place 4: 5f //当前事务中没有写入非事务性存储引擎的表
# Place 5: 5f //当前事务中没有写入事务性存储引擎的表
# Place 6: 5f //当前事务中没有使用不安全的语句
# Place 7: 5f //没有结果集
# Place 8: 5f //没有锁表

客户端执行insert into t1 values(111)封装的数据包
1b 00 00 # playload_length
00 # sequence_id
03 # command_type COM_QUERY
696e7365727420696e746f2074312076616c7565732831313129 # insert into t1 values(111)

server端返回的数据包：response
14 00 00 # playload_length
01 # sequence_id
00010003400000000b050908 
54 5f 5f 5f 57 5f 5f 5f # 事务状态信息 T___W___
# Place 1: 54 //显式的开启一个事务
# Place 2: 5f //当前事务中没有读取非事务性存储引擎的表
# Place 3: 5f //当前事务中没有读取事务性存储引擎的表
# Place 4: 5f //当前事务中没有写入非事务性存储引擎的表
# Place 5: 57 //当前事务中有写入事务性存储引擎的表
# Place 6: 5f //当前事务中没有使用不安全的语句
# Place 7: 5f //没有结果集
# Place 8: 5f //没有锁表

客户端执行commit；封装的数据包
07 00 00 # playload_length
00 # sequence_id
03 # command_type COM_QUERY
636f6d6d6974 # commit

server端返回的数据包：response
1400000100000002400000000b050908
5f 5f 5f 5f 5f 5f 5f 5f # 事务状态信息________
# Place 1: 5f //没有活跃的事务
# Place 2: 5f //当前事务中没有读取非事务性存储引擎的表
# Place 3: 5f //当前事务中没有读取事务性存储引擎的表
# Place 4: 5f //当前事务中没有写入非事务性存储引擎的表
# Place 5: 5f //当前事务中没有写入事务性存储引擎的表
# Place 6: 5f //当前事务中没有使用不安全的语句
# Place 7: 5f //没有结果集
# Place 8: 5f //没有锁表

```
#### 2.2.5 session_track_transaction_info = 2
将session_track_transaction_info参数设置为2的时候，会显示更加详细的事务状态信息。
```
客户端执行begin；封装的数据包
06 00 00 # playload_length
00 # sequence_id
03 # command_type COM_QUERY
626567696e # begin

server端返回的数据包：response
29 00 00 # playload_length
01 # sequence_id
000000034000000020050908
54 5f 5f 5f 5f 5f 5f 5f # 事务状态信息 T_______
0413125354415254205452414e53414354494f4e3b # START TRANSACTION;
# Place 1: 54 //显式的开启一个事务
# Place 2: 5f //当前事务中没有读取非事务性存储引擎的表
# Place 3: 5f //当前事务中没有读取事务性存储引擎的表
# Place 4: 5f //当前事务中没有写入非事务性存储引擎的表
# Place 5: 5f //当前事务中没有写入事务性存储引擎的表
# Place 6: 5f //当前事务中没有使用不安全的语句
# Place 7: 5f //没有结果集
# Place 8: 5f //没有锁表


客户端执行 insert into t1 values(222)封装的数据包
1b 00 00 # playload_length
00 # sequence_id
03 # command_type COM_QUERY
696e7365727420696e746f2074312076616c7565732832323229 # insert into t1 values(222)

server端返回的数据包：response
14 00 00 # playload_length
01 # sequence_id
00010003400000000b050908
54 5f 5f 5f 57 5f 5f 5f # 事务状态信息 T___W___
# Place 1: 5f //没有活跃的事务
# Place 2: 5f //当前事务中没有读取非事务性存储引擎的表
# Place 3: 5f //当前事务中没有读取事务性存储引擎的表
# Place 4: 5f //当前事务中没有写入非事务性存储引擎的表
# Place 5: 5f //当前事务中没有写入事务性存储引擎的表
# Place 6: 5f //当前事务中没有使用不安全的语句
# Place 7: 5f //没有结果集
# Place 8: 5f //没有锁表


客户端执行commit；封装的数据包
07 00 00 # playload_length
00 # sequence_id
03 # command_type COM_QUERY
636f6d6d6974 # commit

server端返回的数据包：response
17 00 00 # playload_length
01 # sequence_id
00000002400000000e050908 
5f 5f 5f 5f 5f 5f 5f 5f # 事务状态信息 ________
040100
# Place 1: 5f //没有活跃的事务
# Place 2: 5f //当前事务中没有读取非事务性存储引擎的表
# Place 3: 5f //当前事务中没有读取事务性存储引擎的表
# Place 4: 5f //当前事务中没有写入非事务性存储引擎的表
# Place 5: 5f //当前事务中没有写入事务性存储引擎的表
# Place 6: 5f //当前事务中没有使用不安全的语句
# Place 7: 5f //没有结果集
# Place 8: 5f //没有锁表

```

## 3. 总结
通过上面的实验中，我们可以看到，在设置该参数之后，我们可以在MySQL的返回数据包中获取到当前连接的事务状态信息。那么我们就可以将这一特性应用到数据库中间件上，使中间件在节点故障的情况下，能够自动迁移连接，减少对用户影响。但是，这在实现上存在一定难度，因为这些连接的事务状态信息是被保存在返回的数据包中。我们想要利用这些事务状态信息的话，需要对MySQL的连接程序最一定的修改。



## 4. 参考文档
* 淘宝内核月报——《MySQL·引擎特性·MySQL内核对读写分离的支持》：http://mysql.taobao.org/monthly/2018/01/02/
* WL#663：Detect transaction boundaries: https://dev.mysql.com/worklog/task/?spm=5176.100239.blogcont221.10.57969ea05YrWEE&id=6631
* WL#4797:Extending protocol's OK packet：https://dev.mysql.com/worklog/task/?id=4797
